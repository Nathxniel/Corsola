concurrency tips and shit

type Strategy a = a -> Eval a

seq :: a -> b -> b
seq =
  it evaluates the first argument to weak head normal form
  and then returns the second
  O(1)

evaluate :: a -> IO a
evaluate =
  it evaluates a thunk to its weak head normal form
  and then puts it in the IO monad.

rpar :: a -> Eval a
rpar a =
  spawns a thread and goes and calculates(a)
  and then puts the result in an the Eval monad
  (to be evaluated later)   

rseq :: a -> Eval a
rseq =
  spawns a thread to do a calculation
  but it evaluates it to WHNF before putting it in Eval monad

runEval :: Eval a -> a
runEval =
  it evaluates all the thunks in an Eval monad
  (use do block for them)

force :: NFData a => a -> a
force =
  it forces the entire structure of its argument to be evaluated
  (can be defined as ```force x = deepseq x x```)

class NFData a where
  rnf :: a -> ()
  rnf a = 
    rnf stands for "reduce to normal form"
    so it just evalutes the argument and returns null
    (default is ```rnf a = a `seq` ()```)

deepseq :: NFData a => a -> b -> b
deepseq
  = evaluate first arg to normal form (not weak head)
    and return second arg
    (```deepseq a b = rnf a `seq` b```)
    O(n)

using :: a -> Strategy a -> a
using
  = applies a strategy to first argument then evaluates it
    (```x `using` s = runEval (s x)```)
    remember that strategies are essentially like "parallel id"

r0 :: Strategy a
r0 =
  dont evaluate the argument, literally like id
  (```r0 = return```)

rdeepseq :: Strategy a
rdeepseq = 
  fully evaluates its argument to normal form

rparwith :: Strategy a -> Strategy a
rparwith =
  it uses a given strategy to create a new strategy
  that works in parallel

parList :: Strategy a -> Strategy [a]
parList s l =
  applies s to every element in l
