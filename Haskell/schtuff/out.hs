ImprtStat "System.IO (readFile, writeFile) \n"
ImprtStat "System.Environment (getArgs) \n"
ImprtStat "Control.Monad \n"
ImprtStat "Control.Applicative \n"
ImprtStat "Data.Char \n"
ImprtStat "Data.List \n"
ImprtStat "qualified Data.Set as S \n \n type Parser = [String] -> [String] \n type Block = [Statement] \n data Statement = Fstat (String, String)"
SLineC " function (lhs, rhs)"
FLine "| FLine String"
SLineC " line within a function"
FLine "| FuncDef String"
SLineC " function definitions"
FLine "| SLineC String"
SLineC " single line comments"
FLine "| MLineC String"
SLineC " multiline comments"
FLine "| MdleStat String"
SLineC " module statements"
FLine "| ImprtStat String"
SLineC " import statements"
FLine "| Pattern (Block, Block)"
SLineC " (body, where clause)"
FLine "deriving (Show) \n \n"
SLineC " File IO version main"
FLine "main :: IO () \n main = do \n [readfile, writefile] <- getArgs \n ls <- lines <$> readFile readfile \n (writeFile writefile) . show . parse2 . parse1 $ ls \n \n"
MLineC " Utility function: \n - \n - Maps a function over a list adding an element inbetween \n"
FLine "intersperseMap :: String -> (String -> [String]) -> Parser \n intersperseMap d f \n = foldr (\\x acc -> (f x) ++ (d:acc)) [] \n \n"
MLineC " The Parser \n - \n - Converts lines into readable format \n - Identifies comments and functions \n - Converts \n"
FLine "parse :: Parser \n parse ls \n = parse3 . parse2 . parse1 $ ls \n \n"
MLineC " Converts lines into readable format \n - \n - \n"
FLine "parse1 :: Parser \n parse1 \n = intersperseMap \"\\n\" words \n \n"
MLineC " Identifies: \n - \n - Comments \n - Function lines \n - Module and import statements \n"
FLine "parse2 :: [String] -> Block \n parse2 tks = \n case tks of \n [] -> [] \n (\"\\n\"):r -> parse2 r \n (\"-}\"):r -> parse2 r \n ('-':'-':t):r -> (fst $ parseSLineC (t:r)) : (parse2.snd.parseSLineC $ (t:r)) \n ('{':'-':t):r -> (fst $ parseMLineC (t:r)) : (parse2.snd.parseMLineC $ (t:r)) \n (\"import\"):r -> (fst $ parseImprtStat r) : (parse2.snd.parseImprtStat $ r) \n (\"module\"):r -> (fst $ parseMdleStat r) : (parse2.snd.parseMdleStat $ r) \n (t:r) -> (fst $ parseFunc (t:r)) : (parse2.snd.parseFunc $ (t:r)) \n \n parse3 = undefined \n \n parseSLineC :: [String] -> (Statement, [String]) \n parseSLineC tks \n = (SLineC (unwords sline), rest) \n where \n (sline, rest) = break (==\"\\n\") tks \n \n parseMLineC :: [String] -> (Statement, [String]) \n parseMLineC tks \n = (MLineC (unwords mline), rest) \n where \n (mline, rest) = break (==\"-}\") tks \n \n"
SLineC " helper :/"
FLine "parseMultiline :: [String] -> [String] \n -> (String -> Statement) -> (Statement, [String]) \n parseMultiline tks acc typ = \n case tks of \n [] -> (typ (unwords acc), []) \n ('-':'-':_):_ -> (typ (unwords acc), tks) \n ('{':'-':_):_ -> (typ (unwords acc), tks) \n (\"import\"):_ -> (typ (unwords acc), tks) \n (\"module\"):_ -> (typ (unwords acc), tks) \n (t:ts) -> parseMultiline ts (acc ++ [t]) typ \n \n parseImprtStat :: [String] -> (Statement, [String]) \n parseImprtStat tks \n = parseMultiline tks [] ImprtStat \n \n parseMdleStat :: [String] -> (Statement, [String]) \n parseMdleStat tks \n = parseMultiline tks [] MdleStat \n \n parseFunc :: [String] -> (Statement, [String]) \n parseFunc tks \n = parseMultiline tks [] FLine \n"
um